{"version":3,"sources":["webpack:///ui-scroll.min.js","webpack:///webpack/bootstrap 34380bdd85f032eea2e2","webpack:///./src/modules/adapter.js","webpack:///./src/modules/buffer.js","webpack:///./src/modules/elementRoutines.js","webpack:///./src/modules/jqLiteExtras.js","webpack:///./src/modules/viewport.js","webpack:///./src/modules/padding.js","webpack:///./src/ui-scroll.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","getCtrlOnData","attr","element","onSyntax","match","length","window","console","log","ctrl","tail","candidate","candidateScope","scope","candidateName","target","source","parent","Error","_createClass","defineProperties","props","descriptor","writable","key","protoProps","staticProps","Adapter","viewport","buffer","adjustBuffer","reload","$attr","$parse","$scope","this","isLoading","disabled","viewportScope","getScope","startScope","$parent","publicContext","assignAdapter","adapter","generatePublicContext","adapterAttr","replace","ctrlOnData","adapterOnScope","assign","error","message","angular","extend","_this","publicMethods","bind","publicProps","set","bof","eof","arg1","arg2","_this2","isFunction","slice","forEach","wrapper","applyUpdate","item","index","first","newItems","append","clipTop","clipBottom","prepend","rowTop","topHeight","topDone","bottomDone","itemTop","offset","top","itemHeight","outerHeight","topDataPos","topVisiblePos","bottomVisiblePos","isEOF","_this3","isArray","keepIt","pos","indexOf","reverse","newItem","insert","op","default","ScrollBuffer","elementRoutines","bufferSize","create","Array","size","reset","startIndex","remove","next","minIndex","maxIndex","minIndexUser","maxIndexUser","items","Math","max","min","operation","splice","push","unshift","isNumber","removeElement","removeElementAnimated","effectiveHeight","elements","Number","MAX_VALUE","bottom","NEGATIVE_INFINITY","offsetParent","ElementRoutines","$injector","$q","$animate","has","isAngularVersionLessThen1_3","version","major","minor","newElement","previousElement","after","$destroy","insertElement","deferred","defer","enter","resolve","promise","leave","then","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","done","err","JQLiteExtras","scrollTo","self","direction","elem","_top$left$direction","left","method","prop","preserve","isWindow","isDefined","document","documentElement","getMeasurements","measure","base","borderA","borderB","computedMarginA","computedMarginB","computedStyle","dirA","dirB","marginA","marginB","paddingA","paddingB","height","width","padding","border","margin","_width$height$measure","offsetWidth","offsetHeight","getStyle","convertToPx","getWidthHeight","result","measurements","outer","outerfull","style","parseFloat","css","nodeType","obj","location","alert","setInterval","getComputedStyle","currentStyle","rs","rsLeft","core_pnum","RegExp","test","runtimeStyle","pixelLeft","before","newElem","children","j","ref","contents","outerHTML","option","outerWidth","docElem","win","box","doc","ownerDocument","arguments","getBoundingClientRect","defaultView","parentWindow","pageYOffset","scrollTop","clientTop","pageXOffset","scrollLeft","clientLeft","Viewport","viewportController","$rootScope","bufferPadding","topPadding","bottomPadding","container","overflow-anchor","overflow-y","display","createPaddingElements","template","_padding2","applyContainerStyle","bottomDataPos","scrollHeight","e","sibling","insertElementAnimated","shouldLoadBottom","overage","overageHeight","emptySpaceHeight","cache","add","adjustPaddings","shouldLoadTop","topPaddingHeight","reduce","summ","bottomPaddingHeight","visibleItemsHeight","averageItemHeight","adjustTopPadding","adjustBottomPadding","topPaddingHeightAdd","bottomPaddingHeightAdd","onAfterMinIndexSet","topPaddingHeightOld","diff","onAfterPrepend","updates","prepended","paddingHeight","resetTopPadding","clear","resetBottomPadding","removeItem","_padding","Cache","$index","sort","a","b","Padding","tagName","toLowerCase","find","_interopRequireDefault","_jqLiteExtras","_jqLiteExtras2","_elementRoutines","_elementRoutines2","_buffer","_buffer2","_viewport","_viewport2","_adapter","_adapter2","service","run","jqLiteExtras","jQuery","registerFor","directive","restrict","controller","child","$timeout","link","controllers","linker","parseNumericAttr","defaultValue","isNaN","onRenderHandlersRunner","onRenderHandlers","handler","preDefineIndexProperty","datasource","propName","defineIndexProperty","propUserName","getOwnPropertyDescriptor","isInvalid","rid","ridActual","$$destroyed","bindEvents","resizeAndScrollHandler","unbindEvents","unbind","isElementVisible","visibilityWatcher","unregisterVisibilityWatcher","pending","insertWrapperContent","insertAfter","createElement","$watch","addClass","promises","clone","itemName","transform","tdInitializer","uiScrollTdInitializer","linking","onLink","updateDOM","toBePrepended","toBeRemoved","inserted","concat","removed","animated","updatePaddings","all","enqueueFetch","loading","fetch","$$phase","$digest","w","removeClass","calculateProperties","adjustBufferAfterFetch","shift","fetchNext","fetchPrevious","wheelHandler","event","yMax","clientHeight","preventDefault","uiScroll","datasourceName","isDatasourceValid","isObject","success","count","$on","require","transclude","priority","terminal"],"mappings":"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","file":"ui-scroll.min.js","sourcesContent":["/*!\r\n * angular-ui-scroll (uncompressed)\r\n * https://github.com/angular-ui/ui-scroll\r\n * Version: 1.7.0-rc.2 -- 2017-10-18T14:14:42.723Z\r\n * License: MIT\r\n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getCtrlOnData(attr, element) {\n  var onSyntax = attr.match(/^(.+)(\\s+on\\s+)(.+)?/);\n  if (onSyntax && onSyntax.length === 4) {\n    window.console.log('Angular ui-scroll adapter assignment warning. \"Controller On\" syntax has been deprecated since ui-scroll v1.6.1.');\n    var ctrl = onSyntax[3];\n    var tail = onSyntax[1];\n    var candidate = element;\n    while (candidate.length) {\n      var candidateScope = candidate.scope(); // doesn't work when debugInfoEnabled flag = true\n      var candidateName = (candidate.attr('ng-controller') || '').match(/(\\w(?:\\w|\\d)*)(?:\\s+as\\s+(\\w(?:\\w|\\d)*))?/);\n      if (candidateName && candidateName[1] === ctrl) {\n        return {\n          target: candidateScope,\n          source: tail\n        };\n      }\n      candidate = candidate.parent();\n    }\n    throw new Error('Angular ui-scroll adapter assignment error. Failed to locate target controller \"' + ctrl + '\" to inject \"' + tail + '\"');\n  }\n}\n\nvar Adapter = function () {\n  function Adapter(viewport, buffer, adjustBuffer, reload, $attr, $parse, element, $scope) {\n    _classCallCheck(this, Adapter);\n\n    this.viewport = viewport;\n    this.buffer = buffer;\n    this.adjustBuffer = adjustBuffer;\n    this.reload = reload;\n\n    this.isLoading = false;\n    this.disabled = false;\n\n    var viewportScope = viewport.getScope();\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\n\n    this.publicContext = {};\n    this.assignAdapter($attr.adapter, $parse, element);\n    this.generatePublicContext($attr, $parse);\n  }\n\n  _createClass(Adapter, [{\n    key: 'assignAdapter',\n    value: function assignAdapter(adapterAttr, $parse, element) {\n      if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\n        return;\n      }\n      var ctrlOnData = getCtrlOnData(adapterAttr, element);\n      var adapterOnScope = void 0;\n\n      try {\n        if (ctrlOnData) {\n          // \"Controller On\", deprecated since v1.6.1\n          $parse(ctrlOnData.source).assign(ctrlOnData.target, {});\n          adapterOnScope = $parse(ctrlOnData.source)(ctrlOnData.target);\n        } else {\n          $parse(adapterAttr).assign(this.startScope, {});\n          adapterOnScope = $parse(adapterAttr)(this.startScope);\n        }\n      } catch (error) {\n        error.message = 'Angular ui-scroll Adapter assignment exception.\\n' + ('Can\\'t parse \"' + adapterAttr + '\" expression.\\n') + error.message;\n        throw error;\n      }\n\n      angular.extend(adapterOnScope, this.publicContext);\n      this.publicContext = adapterOnScope;\n    }\n  }, {\n    key: 'generatePublicContext',\n    value: function generatePublicContext($attr, $parse) {\n      var _this = this;\n\n      // these methods will be accessible out of ui-scroll via user defined adapter\n      var publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty'];\n      for (var i = publicMethods.length - 1; i >= 0; i--) {\n        this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\n      }\n\n      // these read-only props will be accessible out of ui-scroll via user defined adapter\n      var publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\n\n      var _loop = function _loop(_i) {\n        var property = void 0,\n            attr = $attr[publicProps[_i]];\n        Object.defineProperty(_this, publicProps[_i], {\n          get: function get() {\n            return property;\n          },\n          set: function set(value) {\n            property = value;\n            _this.publicContext[publicProps[_i]] = value;\n            if (attr) {\n              $parse(attr).assign(_this.startScope, value);\n            }\n          }\n        });\n      };\n\n      for (var _i = publicProps.length - 1; _i >= 0; _i--) {\n        _loop(_i);\n      }\n\n      // non-read-only public property\n      Object.defineProperty(this.publicContext, 'disabled', {\n        get: function get() {\n          return _this.disabled;\n        },\n        set: function set(value) {\n          return !(_this.disabled = value) ? _this.adjustBuffer() : null;\n        }\n      });\n    }\n  }, {\n    key: 'loading',\n    value: function loading(value) {\n      this['isLoading'] = value;\n    }\n  }, {\n    key: 'isBOF',\n    value: function isBOF() {\n      return this.buffer.bof;\n    }\n  }, {\n    key: 'isEOF',\n    value: function isEOF() {\n      return this.buffer.eof;\n    }\n  }, {\n    key: 'isEmpty',\n    value: function isEmpty() {\n      return !this.buffer.length;\n    }\n  }, {\n    key: 'applyUpdates',\n    value: function applyUpdates(arg1, arg2) {\n      var _this2 = this;\n\n      if (angular.isFunction(arg1)) {\n        // arg1 is the updater function, arg2 is ignored\n        this.buffer.slice(0).forEach(function (wrapper) {\n          // we need to do it on the buffer clone, because buffer content\n          // may change as we iterate through\n          _this2.applyUpdate(wrapper, arg1(wrapper.item, wrapper.scope, wrapper.element));\n        });\n      } else {\n        // arg1 is item index, arg2 is the newItems array\n        if (arg1 % 1 !== 0) {\n          // checking if it is an integer\n          throw new Error('applyUpdates - ' + arg1 + ' is not a valid index');\n        }\n\n        var index = arg1 - this.buffer.first;\n        if (index >= 0 && index < this.buffer.length) {\n          this.applyUpdate(this.buffer[index], arg2);\n        }\n      }\n\n      this.adjustBuffer();\n    }\n  }, {\n    key: 'append',\n    value: function append(newItems) {\n      this.buffer.append(newItems);\n      this.adjustBuffer();\n      this.viewport.clipTop();\n      this.viewport.clipBottom();\n    }\n  }, {\n    key: 'prepend',\n    value: function prepend(newItems) {\n      this.buffer.prepend(newItems);\n      this.adjustBuffer();\n      this.viewport.clipTop();\n      this.viewport.clipBottom();\n    }\n  }, {\n    key: 'calculateProperties',\n    value: function calculateProperties() {\n      var rowTop = null,\n          topHeight = 0;\n      var topDone = false,\n          bottomDone = false;\n      var length = this.buffer.length;\n\n      for (var i = 0; i < length; i++) {\n        var item = this.buffer[i];\n        var itemTop = item.element.offset().top;\n\n        if (rowTop !== itemTop) {\n          // a new row condition\n          var itemHeight = item.element.outerHeight(true);\n          var top = this.viewport.topDataPos() + topHeight + itemHeight;\n\n          if (!topDone && top > this.viewport.topVisiblePos()) {\n            topDone = true;\n            this['topVisible'] = item.item;\n            this['topVisibleElement'] = item.element;\n            this['topVisibleScope'] = item.scope;\n          }\n\n          if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || i === length - 1 && this.isEOF())) {\n            bottomDone = true;\n            this['bottomVisible'] = item.item;\n            this['bottomVisibleElement'] = item.element;\n            this['bottomVisibleScope'] = item.scope;\n          }\n          topHeight += itemHeight;\n        }\n\n        rowTop = itemTop;\n\n        if (topDone && bottomDone) {\n          break;\n        }\n      }\n    }\n  }, {\n    key: 'applyUpdate',\n    value: function applyUpdate(wrapper, newItems) {\n      var _this3 = this;\n\n      if (!angular.isArray(newItems)) {\n        return;\n      }\n\n      var keepIt = void 0;\n      var pos = this.buffer.indexOf(wrapper) + 1;\n\n      newItems.reverse().forEach(function (newItem) {\n        if (newItem === wrapper.item) {\n          keepIt = true;\n          pos--;\n        } else {\n          _this3.buffer.insert(pos, newItem);\n        }\n      });\n\n      if (!keepIt) {\n        wrapper.op = 'remove';\n      }\n    }\n  }]);\n\n  return Adapter;\n}();\n\nexports.default = Adapter;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = ScrollBuffer;\nfunction ScrollBuffer(elementRoutines, bufferSize) {\n  var buffer = Object.create(Array.prototype);\n\n  angular.extend(buffer, {\n    size: bufferSize,\n\n    reset: function reset(startIndex) {\n      buffer.remove(0, buffer.length);\n      buffer.eof = false;\n      buffer.bof = false;\n      buffer.first = startIndex;\n      buffer.next = startIndex;\n      buffer.minIndex = startIndex;\n      buffer.maxIndex = startIndex;\n      buffer.minIndexUser = null;\n      buffer.maxIndexUser = null;\n    },\n    append: function append(items) {\n      items.forEach(function (item) {\n        ++buffer.next;\n        buffer.insert('append', item);\n      });\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\n    },\n    prepend: function prepend(items) {\n      items.reverse().forEach(function (item) {\n        --buffer.first;\n        buffer.insert('prepend', item);\n      });\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\n    },\n\n\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\n    insert: function insert(operation, item) {\n      var wrapper = {\n        item: item\n      };\n\n      if (operation % 1 === 0) {\n        // it is an insert\n        wrapper.op = 'insert';\n        buffer.splice(operation, 0, wrapper);\n      } else {\n        wrapper.op = operation;\n        switch (operation) {\n          case 'append':\n            buffer.push(wrapper);\n            break;\n          case 'prepend':\n            buffer.unshift(wrapper);\n            break;\n        }\n      }\n    },\n\n\n    // removes elements from buffer\n    remove: function remove(arg1, arg2) {\n      if (angular.isNumber(arg1)) {\n        // removes items from arg1 (including) through arg2 (excluding)\n        for (var i = arg1; i < arg2; i++) {\n          elementRoutines.removeElement(buffer[i]);\n        }\n\n        return buffer.splice(arg1, arg2 - arg1);\n      }\n      // removes single item(wrapper) from the buffer\n      buffer.splice(buffer.indexOf(arg1), 1);\n\n      return elementRoutines.removeElementAnimated(arg1);\n    },\n    effectiveHeight: function effectiveHeight(elements) {\n      if (!elements.length) {\n        return 0;\n      }\n      var top = Number.MAX_VALUE;\n      var bottom = Number.NEGATIVE_INFINITY;\n      elements.forEach(function (wrapper) {\n        if (wrapper.element[0].offsetParent) {\n          // element style is not display:none\n          top = Math.min(top, wrapper.element.offset().top);\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\n        }\n      });\n      return Math.max(0, bottom - top);\n    }\n  });\n\n  return buffer;\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ElementRoutines = function () {\n  function ElementRoutines($injector, $q) {\n    _classCallCheck(this, ElementRoutines);\n\n    this.$animate = $injector.has && $injector.has('$animate') ? $injector.get('$animate') : null;\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\n    this.$q = $q;\n  }\n\n  _createClass(ElementRoutines, [{\n    key: 'insertElement',\n    value: function insertElement(newElement, previousElement) {\n      previousElement.after(newElement);\n      return [];\n    }\n  }, {\n    key: 'removeElement',\n    value: function removeElement(wrapper) {\n      wrapper.element.remove();\n      wrapper.scope.$destroy();\n      return [];\n    }\n  }, {\n    key: 'insertElementAnimated',\n    value: function insertElementAnimated(newElement, previousElement) {\n      if (!this.$animate) {\n        return this.insertElement(newElement, previousElement);\n      }\n\n      if (this.isAngularVersionLessThen1_3) {\n        var deferred = this.$q.defer();\n        // no need for parent - previous element is never null\n        this.$animate.enter(newElement, null, previousElement, function () {\n          return deferred.resolve();\n        });\n\n        return [deferred.promise];\n      }\n\n      // no need for parent - previous element is never null\n      return [this.$animate.enter(newElement, null, previousElement)];\n    }\n  }, {\n    key: 'removeElementAnimated',\n    value: function removeElementAnimated(wrapper) {\n      if (!this.$animate) {\n        return this.removeElement(wrapper);\n      }\n\n      if (this.isAngularVersionLessThen1_3) {\n        var deferred = this.$q.defer();\n        this.$animate.leave(wrapper.element, function () {\n          wrapper.scope.$destroy();\n          return deferred.resolve();\n        });\n\n        return [deferred.promise];\n      }\n\n      return [this.$animate.leave(wrapper.element).then(function () {\n        return wrapper.scope.$destroy();\n      })];\n    }\n  }]);\n\n  return ElementRoutines;\n}();\n\nexports.default = ElementRoutines;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\n\nvar JQLiteExtras = function () {\n  function JQLiteExtras() {\n    _classCallCheck(this, JQLiteExtras);\n  }\n\n  _createClass(JQLiteExtras, [{\n    key: 'registerFor',\n    value: function registerFor(element) {\n      var convertToPx = void 0,\n          css = void 0,\n          getStyle = void 0,\n          isWindow = void 0;\n      // angular implementation blows up if elem is the window\n      css = angular.element.prototype.css;\n\n      element.prototype.css = function (name, value) {\n        var self = this;\n        var elem = self[0];\n        if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\n          return css.call(self, name, value);\n        }\n      };\n\n      // as defined in angularjs v1.0.5\n      isWindow = function isWindow(obj) {\n        return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n      };\n\n      function scrollTo(self, direction, value) {\n        var elem = self[0];\n\n        var _top$left$direction = _slicedToArray({\n          top: ['scrollTop', 'pageYOffset', 'scrollLeft'],\n          left: ['scrollLeft', 'pageXOffset', 'scrollTop']\n        }[direction], 3),\n            method = _top$left$direction[0],\n            prop = _top$left$direction[1],\n            preserve = _top$left$direction[2];\n\n        if (isWindow(elem)) {\n          if (angular.isDefined(value)) {\n            return elem.scrollTo(self[preserve].call(self), value);\n          }\n          return prop in elem ? elem[prop] : elem.document.documentElement[method];\n        } else {\n          if (angular.isDefined(value)) {\n            elem[method] = value;\n          }\n          return elem[method];\n        }\n      }\n\n      if (window.getComputedStyle) {\n        getStyle = function getStyle(elem) {\n          return window.getComputedStyle(elem, null);\n        };\n        convertToPx = function convertToPx(elem, value) {\n          return parseFloat(value);\n        };\n      } else {\n        getStyle = function getStyle(elem) {\n          return elem.currentStyle;\n        };\n        convertToPx = function convertToPx(elem, value) {\n          var left = void 0,\n              result = void 0,\n              rs = void 0,\n              rsLeft = void 0,\n              style = void 0;\n          var core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\n          var rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\n\n          if (!rnumnonpx.test(value)) {\n            return parseFloat(value);\n          }\n\n          // ported from JQuery\n          style = elem.style;\n          left = style.left;\n          rs = elem.runtimeStyle;\n          rsLeft = rs && rs.left;\n          if (rs) {\n            rs.left = style.left;\n          }\n          // put in the new values to get a computed style out\n          style.left = value;\n          result = style.pixelLeft;\n          style.left = left;\n          if (rsLeft) {\n            rs.left = rsLeft;\n          }\n          return result;\n        };\n      }\n\n      function getMeasurements(elem, measure) {\n        var base = void 0,\n            borderA = void 0,\n            borderB = void 0,\n            computedMarginA = void 0,\n            computedMarginB = void 0,\n            computedStyle = void 0,\n            dirA = void 0,\n            dirB = void 0,\n            marginA = void 0,\n            marginB = void 0,\n            paddingA = void 0,\n            paddingB = void 0;\n\n        if (isWindow(elem)) {\n          base = document.documentElement[{ height: 'clientHeight', width: 'clientWidth' }[measure]];\n\n          return {\n            base: base,\n            padding: 0,\n            border: 0,\n            margin: 0\n          };\n        }\n\n        // Start with offset property\n\n        var _width$height$measure = _slicedToArray({\n          width: [elem.offsetWidth, 'Left', 'Right'],\n          height: [elem.offsetHeight, 'Top', 'Bottom']\n        }[measure], 3);\n\n        base = _width$height$measure[0];\n        dirA = _width$height$measure[1];\n        dirB = _width$height$measure[2];\n\n\n        computedStyle = getStyle(elem);\n        paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\n        paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\n        borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\n        borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\n        computedMarginA = computedStyle['margin' + dirA];\n        computedMarginB = computedStyle['margin' + dirB];\n\n        // I do not care for width for now, so this hack is irrelevant\n        // if ( !supportsPercentMargin )\n        // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\n        // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\n        marginA = convertToPx(elem, computedMarginA) || 0;\n        marginB = convertToPx(elem, computedMarginB) || 0;\n\n        return {\n          base: base,\n          padding: paddingA + paddingB,\n          border: borderA + borderB,\n          margin: marginA + marginB\n        };\n      }\n\n      function getWidthHeight(elem, direction, measure) {\n        var computedStyle = void 0,\n            result = void 0;\n\n        var measurements = getMeasurements(elem, direction);\n\n        if (measurements.base > 0) {\n          return {\n            base: measurements.base - measurements.padding - measurements.border,\n            outer: measurements.base,\n            outerfull: measurements.base + measurements.margin\n          }[measure];\n        }\n\n        // Fall back to computed then uncomputed css if necessary\n        computedStyle = getStyle(elem);\n        result = computedStyle[direction];\n\n        if (result < 0 || result === null) {\n          result = elem.style[direction] || 0;\n        }\n\n        // Normalize \"\", auto, and prepare for extra\n        result = parseFloat(result) || 0;\n\n        return {\n          base: result - measurements.padding - measurements.border,\n          outer: result,\n          outerfull: result + measurements.padding + measurements.border + measurements.margin\n        }[measure];\n      }\n\n      // define missing methods\n      return angular.forEach({\n        before: function before(newElem) {\n          var children, elem, i, j, parent, ref, self;\n          self = this;\n          elem = self[0];\n          parent = self.parent();\n          children = parent.contents();\n          if (children[0] === elem) {\n            return parent.prepend(newElem);\n          } else {\n            for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\n              if (children[i] === elem) {\n                angular.element(children[i - 1]).after(newElem);\n                return;\n              }\n            }\n            throw new Error('invalid DOM structure ' + elem.outerHTML);\n          }\n        },\n        height: function height(value) {\n          var self;\n          self = this;\n          if (angular.isDefined(value)) {\n            if (angular.isNumber(value)) {\n              value = value + 'px';\n            }\n            return css.call(self, 'height', value);\n          } else {\n            return getWidthHeight(this[0], 'height', 'base');\n          }\n        },\n        outerHeight: function outerHeight(option) {\n          return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\n        },\n        outerWidth: function outerWidth(option) {\n          return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\n        },\n\n\n        /*\r\n         The offset setter method is not implemented\r\n         */\n        offset: function offset(value) {\n          var docElem = void 0,\n              win = void 0;\n          var self = this;\n          var box = {\n            top: 0,\n            left: 0\n          };\n          var elem = self[0];\n          var doc = elem && elem.ownerDocument;\n\n          if (arguments.length) {\n            if (value === undefined) {\n              return self;\n            }\n            // TODO: implement setter\n            throw new Error('offset setter method is not implemented');\n          }\n\n          if (!doc) {\n            return;\n          }\n\n          docElem = doc.documentElement;\n\n          // TODO: Make sure it's not a disconnected DOM node\n\n          if (elem.getBoundingClientRect != null) {\n            box = elem.getBoundingClientRect();\n          }\n\n          win = doc.defaultView || doc.parentWindow;\n\n          return {\n            top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\n            left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\n          };\n        },\n        scrollTop: function scrollTop(value) {\n          return scrollTo(this, 'top', value);\n        },\n        scrollLeft: function scrollLeft(value) {\n          return scrollTo(this, 'left', value);\n        }\n      }, function (value, key) {\n        if (!element.prototype[key]) {\n          return element.prototype[key] = value;\n        }\n      });\n    }\n  }]);\n\n  return JQLiteExtras;\n}();\n\nexports.default = JQLiteExtras;\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Viewport;\n\nvar _padding = __webpack_require__(5);\n\nvar _padding2 = _interopRequireDefault(_padding);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\n  var topPadding = null;\n  var bottomPadding = null;\n  var viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\n  var container = viewportController && viewportController.container ? viewportController.container : undefined;\n  var scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\n\n  viewport.css({\n    'overflow-anchor': 'none',\n    'overflow-y': 'auto',\n    'display': 'block'\n  });\n\n  function bufferPadding() {\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\n  }\n\n  angular.extend(viewport, {\n    getScope: function getScope() {\n      return scope;\n    },\n    createPaddingElements: function createPaddingElements(template) {\n      topPadding = new _padding2.default(template);\n      bottomPadding = new _padding2.default(template);\n      element.before(topPadding);\n      element.after(bottomPadding);\n    },\n    applyContainerStyle: function applyContainerStyle() {\n      if (container && container !== viewport) {\n        viewport.css('height', window.getComputedStyle(container[0]).height);\n      }\n    },\n    bottomDataPos: function bottomDataPos() {\n      var scrollHeight = viewport[0].scrollHeight;\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\n      return scrollHeight - bottomPadding.height();\n    },\n    topDataPos: function topDataPos() {\n      return topPadding.height();\n    },\n    bottomVisiblePos: function bottomVisiblePos() {\n      return viewport.scrollTop() + viewport.outerHeight();\n    },\n    topVisiblePos: function topVisiblePos() {\n      return viewport.scrollTop();\n    },\n    insertElement: function insertElement(e, sibling) {\n      return elementRoutines.insertElement(e, sibling || topPadding);\n    },\n    insertElementAnimated: function insertElementAnimated(e, sibling) {\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding);\n    },\n    shouldLoadBottom: function shouldLoadBottom() {\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\n    },\n    clipBottom: function clipBottom() {\n      // clip the invisible items off the bottom\n      var overage = 0;\n      var overageHeight = 0;\n      var itemHeight = 0;\n      var emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\n\n      for (var i = buffer.length - 1; i >= 0; i--) {\n        itemHeight = buffer[i].element.outerHeight(true);\n        if (overageHeight + itemHeight > emptySpaceHeight) {\n          break;\n        }\n        bottomPadding.cache.add(buffer[i]);\n        overageHeight += itemHeight;\n        overage++;\n      }\n\n      if (overage > 0) {\n        buffer.eof = false;\n        buffer.remove(buffer.length - overage, buffer.length);\n        buffer.next -= overage;\n        viewport.adjustPaddings();\n      }\n    },\n    shouldLoadTop: function shouldLoadTop() {\n      return !buffer.bof && viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding();\n    },\n    clipTop: function clipTop() {\n      // clip the invisible items off the top\n      var overage = 0;\n      var overageHeight = 0;\n      var itemHeight = 0;\n      var emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\n\n      for (var i = 0; i < buffer.length; i++) {\n        itemHeight = buffer[i].element.outerHeight(true);\n        if (overageHeight + itemHeight > emptySpaceHeight) {\n          break;\n        }\n        topPadding.cache.add(buffer[i]);\n        overageHeight += itemHeight;\n        overage++;\n      }\n\n      if (overage > 0) {\n        // we need to adjust top padding element before items are removed from top\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\n        topPadding.height(topPadding.height() + overageHeight);\n        buffer.bof = false;\n        buffer.remove(0, overage);\n        buffer.first += overage;\n      }\n    },\n    adjustPaddings: function adjustPaddings() {\n      if (!buffer.length) {\n        return;\n      }\n\n      // precise heights calculation, items that were in buffer once\n      var topPaddingHeight = topPadding.cache.reduce(function (summ, item) {\n        return summ + (item.index < buffer.first ? item.height : 0);\n      }, 0);\n      var bottomPaddingHeight = bottomPadding.cache.reduce(function (summ, item) {\n        return summ + (item.index >= buffer.next ? item.height : 0);\n      }, 0);\n\n      // average item height based on buffer data\n      var visibleItemsHeight = buffer.reduce(function (summ, item) {\n        return summ + item.element.outerHeight(true);\n      }, 0);\n      var averageItemHeight = (visibleItemsHeight + topPaddingHeight + bottomPaddingHeight) / (buffer.maxIndex - buffer.minIndex + 1);\n\n      // average heights calculation, items that have never been reached\n      var adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\n      var adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\n      var topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\n      var bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\n\n      // paddings combine adjustment\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\n    },\n    onAfterMinIndexSet: function onAfterMinIndexSet(topPaddingHeightOld) {\n      // additional scrollTop adjustment in case of datasource.minIndex external set\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\n        var diff = topPadding.height() - topPaddingHeightOld;\n        viewport.scrollTop(viewport.scrollTop() + diff);\n        diff -= viewport.scrollTop();\n        if (diff > 0) {\n          bottomPadding.height(bottomPadding.height() + diff);\n          viewport.scrollTop(viewport.scrollTop() + diff);\n        }\n      }\n    },\n    onAfterPrepend: function onAfterPrepend(updates) {\n      if (!updates.prepended.length) return;\n      var height = buffer.effectiveHeight(updates.prepended);\n      var paddingHeight = topPadding.height() - height;\n      if (paddingHeight >= 0) {\n        topPadding.height(paddingHeight);\n      } else {\n        topPadding.height(0);\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\n      }\n    },\n    resetTopPadding: function resetTopPadding() {\n      topPadding.height(0);\n      topPadding.cache.clear();\n    },\n    resetBottomPadding: function resetBottomPadding() {\n      bottomPadding.height(0);\n      bottomPadding.cache.clear();\n    },\n    removeItem: function removeItem(item) {\n      topPadding.cache.remove(item);\n      bottomPadding.cache.remove(item);\n      return buffer.remove(item);\n    }\n  });\n\n  return viewport;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = Padding;\nfunction Cache() {\n  var cache = Object.create(Array.prototype);\n\n  angular.extend(cache, {\n    add: function add(item) {\n      for (var i = cache.length - 1; i >= 0; i--) {\n        if (cache[i].index === item.scope.$index) {\n          cache[i].height = item.element.outerHeight();\n          return;\n        }\n      }\n      cache.push({\n        index: item.scope.$index,\n        height: item.element.outerHeight()\n      });\n      cache.sort(function (a, b) {\n        return a.index < b.index ? -1 : a.index > b.index ? 1 : 0;\n      });\n    },\n    remove: function remove(item) {\n      for (var i = cache.length - 1; i >= 0; i--) {\n        if (cache[i].index === item.scope.$index) {\n          cache.splice(i, 1);\n          break;\n        }\n      }\n      for (var _i = cache.length - 1; _i >= 0; _i--) {\n        if (cache[_i].index > item.scope.$index) {\n          cache[_i].index--;\n        }\n      }\n    },\n    clear: function clear() {\n      cache.length = 0;\n    }\n  });\n\n  return cache;\n}\n\nfunction Padding(template) {\n  var result = void 0;\n\n  switch (template.tagName.toLowerCase()) {\n    case 'dl':\n      throw new Error('ui-scroll directive does not support <' + template.tagName + '> as a repeating tag: ' + template.outerHTML);\n    case 'tr':\n      var table = angular.element('<table><tr><td><div></div></td></tr></table>');\n      result = table.find('tr');\n      break;\n    case 'li':\n      result = angular.element('<li></li>');\n      break;\n    default:\n      result = angular.element('<div></div>');\n  }\n\n  result.cache = new Cache();\n\n  return result;\n}\n\n/***/ }),\n/* 6 */,\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _jqLiteExtras = __webpack_require__(3);\n\nvar _jqLiteExtras2 = _interopRequireDefault(_jqLiteExtras);\n\nvar _elementRoutines = __webpack_require__(2);\n\nvar _elementRoutines2 = _interopRequireDefault(_elementRoutines);\n\nvar _buffer = __webpack_require__(1);\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _viewport = __webpack_require__(4);\n\nvar _viewport2 = _interopRequireDefault(_viewport);\n\nvar _adapter = __webpack_require__(0);\n\nvar _adapter2 = _interopRequireDefault(_adapter);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nangular.module('ui.scroll', []).service('jqLiteExtras', function () {\n  return new _jqLiteExtras2.default();\n}).run(['jqLiteExtras', function (jqLiteExtras) {\n  return !window.jQuery ? jqLiteExtras.registerFor(angular.element) : null;\n}]).directive('uiScrollViewport', function () {\n  return {\n    restrict: 'A',\n    controller: ['$scope', '$element', function (scope, element) {\n      var _this = this;\n\n      this.container = element;\n      this.viewport = element;\n      this.scope = scope;\n\n      angular.forEach(element.children(), function (child) {\n        if (child.tagName.toLowerCase() === 'tbody') {\n          _this.viewport = angular.element(child);\n        }\n      });\n\n      return this;\n    }]\n  };\n}).directive('uiScroll', ['$log', '$injector', '$rootScope', '$timeout', '$q', '$parse', function (console, $injector, $rootScope, $timeout, $q, $parse) {\n\n  return {\n    require: ['?^uiScrollViewport'],\n    restrict: 'A',\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    link: link\n  };\n\n  function link($scope, element, $attr, controllers, linker) {\n    var match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n    if (!match) {\n      throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n    }\n\n    function parseNumericAttr(value, defaultValue) {\n      var result = $parse(value)($scope);\n      return isNaN(result) ? defaultValue : result;\n    }\n\n    var BUFFER_MIN = 3;\n    var BUFFER_DEFAULT = 10;\n    var PADDING_MIN = 0.3;\n    var PADDING_DEFAULT = 0.5;\n\n    var datasource = null;\n    var itemName = match[1];\n    var datasourceName = match[2];\n    var viewportController = controllers[0];\n    var bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n    var padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n    var startIndex = parseNumericAttr($attr.startIndex, 1);\n    var ridActual = 0; // current data revision id\n    var pending = [];\n\n    var elementRoutines = new _elementRoutines2.default($injector, $q);\n    var buffer = new _buffer2.default(elementRoutines, bufferSize);\n    var viewport = new _viewport2.default(elementRoutines, buffer, element, viewportController, $rootScope, padding);\n    var adapter = new _adapter2.default(viewport, buffer, adjustBuffer, reload, $attr, $parse, element, $scope);\n\n    if (viewportController) {\n      viewportController.adapter = adapter;\n    }\n\n    var isDatasourceValid = function isDatasourceValid() {\n      return angular.isObject(datasource) && angular.isFunction(datasource.get);\n    };\n    datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n    if (!isDatasourceValid()) {\n      datasource = $injector.get(datasourceName); // try to inject datasource as service\n      if (!isDatasourceValid()) {\n        throw new Error(datasourceName + ' is not a valid datasource');\n      }\n    }\n\n    var onRenderHandlers = [];\n    function onRenderHandlersRunner() {\n      if (onRenderHandlers.length) {\n        angular.forEach(onRenderHandlers, function (handler) {\n          return handler();\n        });\n        onRenderHandlers = [];\n      }\n    }\n    function preDefineIndexProperty(datasource, propName) {\n      var getter = void 0;\n      // need to postpone min/maxIndexUser processing if the view is empty\n      if (datasource.hasOwnProperty(propName) && !buffer.length) {\n        getter = datasource[propName];\n        delete datasource[propName];\n        onRenderHandlers.push(function () {\n          return datasource[propName] = getter;\n        });\n      }\n    }\n\n    function defineIndexProperty(datasource, propName, propUserName) {\n      var descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n      if (descriptor && (descriptor.set || descriptor.get)) {\n        return;\n      }\n      var getter = void 0;\n      preDefineIndexProperty(datasource, propName);\n      Object.defineProperty(datasource, propName, {\n        set: function set(value) {\n          getter = value;\n          buffer[propUserName] = value;\n          var topPaddingHeightOld = viewport.topDataPos();\n          viewport.adjustPaddings();\n          if (propName === 'minIndex') {\n            viewport.onAfterMinIndexSet(topPaddingHeightOld);\n          }\n        },\n        get: function get() {\n          return getter;\n        }\n      });\n    }\n\n    defineIndexProperty(datasource, 'minIndex', 'minIndexUser');\n    defineIndexProperty(datasource, 'maxIndex', 'maxIndexUser');\n\n    var fetchNext = datasource.get.length !== 2 ? function (success) {\n      return datasource.get(buffer.next, bufferSize, success);\n    } : function (success) {\n      datasource.get({\n        index: buffer.next,\n        append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n        count: bufferSize\n      }, success);\n    };\n\n    var fetchPrevious = datasource.get.length !== 2 ? function (success) {\n      return datasource.get(buffer.first - bufferSize, bufferSize, success);\n    } : function (success) {\n      datasource.get({\n        index: buffer.first - bufferSize,\n        prepend: buffer.length ? buffer[0].item : void 0,\n        count: bufferSize\n      }, success);\n    };\n\n    /**\n     * Build padding elements\n     *\n     * Calling linker is the only way I found to get access to the tag name of the template\n     * to prevent the directive scope from pollution a new scope is created and destroyed\n     * right after the builder creation is completed\n     */\n    linker(function (clone, scope) {\n      viewport.createPaddingElements(clone[0]);\n      // we do not include the clone in the DOM. It means that the nested directives will not\n      // be able to reach the parent directives, but in this case it is intentional because we\n      // created the clone to access the template tag name\n      scope.$destroy();\n      clone.remove();\n    });\n\n    $scope.$on('$destroy', function () {\n      unbindEvents();\n      viewport.unbind('mousewheel', wheelHandler);\n    });\n\n    viewport.bind('mousewheel', wheelHandler);\n\n    $timeout(function () {\n      viewport.applyContainerStyle();\n      reload();\n    });\n\n    /* Private function definitions */\n\n    function isInvalid(rid) {\n      return rid && rid !== ridActual || $scope.$$destroyed;\n    }\n\n    function bindEvents() {\n      viewport.bind('resize', resizeAndScrollHandler);\n      viewport.bind('scroll', resizeAndScrollHandler);\n    }\n\n    function unbindEvents() {\n      viewport.unbind('resize', resizeAndScrollHandler);\n      viewport.unbind('scroll', resizeAndScrollHandler);\n    }\n\n    function reload() {\n      viewport.resetTopPadding();\n      viewport.resetBottomPadding();\n      if (arguments.length) {\n        startIndex = arguments[0];\n      }\n      buffer.reset(startIndex);\n      adjustBuffer();\n    }\n\n    function isElementVisible(wrapper) {\n      return wrapper.element.height() && wrapper.element[0].offsetParent;\n    }\n\n    function visibilityWatcher(wrapper) {\n      if (isElementVisible(wrapper)) {\n        buffer.forEach(function (item) {\n          if (angular.isFunction(item.unregisterVisibilityWatcher)) {\n            item.unregisterVisibilityWatcher();\n            delete item.unregisterVisibilityWatcher;\n          }\n        });\n        if (!pending.length) {\n          $timeout(function () {\n            return adjustBuffer();\n          });\n        }\n      }\n    }\n\n    function insertWrapperContent(wrapper, insertAfter) {\n      createElement(wrapper, insertAfter, viewport.insertElement);\n      if (!isElementVisible(wrapper)) {\n        wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(function () {\n          return visibilityWatcher(wrapper);\n        });\n      }\n      wrapper.element.addClass('ng-hide'); // hide inserted elements before data binding\n    }\n\n    function createElement(wrapper, insertAfter, insertElement) {\n      var promises = null;\n      var sibling = insertAfter > 0 ? buffer[insertAfter - 1].element : undefined;\n      linker(function (clone, scope) {\n        promises = insertElement(clone, sibling);\n        wrapper.element = clone;\n        wrapper.scope = scope;\n        scope[itemName] = wrapper.item;\n      });\n      // ui-scroll-grid apply\n      if (adapter.transform) {\n        var tdInitializer = wrapper.scope.uiScrollTdInitializer;\n        if (tdInitializer && tdInitializer.linking) {\n          adapter.transform(wrapper.scope, wrapper.element);\n        } else {\n          wrapper.scope.uiScrollTdInitializer = {\n            onLink: function onLink() {\n              return adapter.transform(wrapper.scope, wrapper.element);\n            },\n            scope: wrapper.scope\n          };\n        }\n      }\n      return promises;\n    }\n\n    function updateDOM() {\n      var promises = [];\n      var toBePrepended = [];\n      var toBeRemoved = [];\n      var inserted = [];\n\n      buffer.forEach(function (wrapper, i) {\n        switch (wrapper.op) {\n          case 'prepend':\n            toBePrepended.unshift(wrapper);\n            break;\n          case 'append':\n            insertWrapperContent(wrapper, i);\n            wrapper.op = 'none';\n            inserted.push(wrapper);\n            break;\n          case 'insert':\n            promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n            wrapper.op = 'none';\n            inserted.push(wrapper);\n            break;\n          case 'remove':\n            toBeRemoved.push(wrapper);\n        }\n      });\n\n      toBeRemoved.forEach(function (wrapper) {\n        return promises = promises.concat(viewport.removeItem(wrapper));\n      });\n\n      if (toBePrepended.length) toBePrepended.forEach(function (wrapper) {\n        insertWrapperContent(wrapper);\n        wrapper.op = 'none';\n      });\n\n      buffer.forEach(function (item, i) {\n        return item.scope.$index = buffer.first + i;\n      });\n\n      return {\n        prepended: toBePrepended,\n        removed: toBeRemoved,\n        inserted: inserted,\n        animated: promises\n      };\n    }\n\n    function updatePaddings(rid, updates) {\n      // schedule another adjustBuffer after animation completion\n      if (updates.animated.length) {\n        $q.all(updates.animated).then(function () {\n          viewport.adjustPaddings();\n          adjustBuffer(rid);\n        });\n      } else {\n        viewport.adjustPaddings();\n      }\n    }\n\n    function enqueueFetch(rid, updates) {\n      if (viewport.shouldLoadBottom()) {\n        if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n          // this means that at least one item appended in the last batch has height > 0\n          if (pending.push(true) === 1) {\n            adapter.loading(true);\n            fetch(rid);\n          }\n        }\n      } else if (viewport.shouldLoadTop()) {\n        if (!updates || buffer.effectiveHeight(updates.prepended) > 0 || pending[0]) {\n          // this means that at least one item appended in the last batch has height > 0\n          // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n          // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n          if (pending.push(false) === 1) {\n            adapter.loading(true);\n            fetch(rid);\n          }\n        }\n      }\n    }\n\n    function adjustBuffer(rid) {\n      if (!rid) {\n        // dismiss pending requests\n        pending = [];\n        rid = ++ridActual;\n      }\n\n      var updates = updateDOM();\n\n      // We need the item bindings to be processed before we can do adjustment\n      !$scope.$$phase && $scope.$digest();\n\n      updates.inserted.forEach(function (w) {\n        return w.element.removeClass('ng-hide');\n      });\n      updates.prepended.forEach(function (w) {\n        return w.element.removeClass('ng-hide');\n      });\n\n      if (isInvalid(rid)) {\n        return;\n      }\n\n      updatePaddings(rid, updates);\n      enqueueFetch(rid);\n\n      if (!pending.length) {\n        adapter.calculateProperties();\n      }\n    }\n\n    function adjustBufferAfterFetch(rid) {\n      var updates = updateDOM();\n\n      // We need the item bindings to be processed before we can do adjustment\n      !$scope.$$phase && $scope.$digest();\n\n      updates.inserted.forEach(function (w) {\n        return w.element.removeClass('ng-hide');\n      });\n      updates.prepended.forEach(function (w) {\n        return w.element.removeClass('ng-hide');\n      });\n\n      viewport.onAfterPrepend(updates);\n\n      if (isInvalid(rid)) {\n        return;\n      }\n\n      updatePaddings(rid, updates);\n      onRenderHandlersRunner();\n      enqueueFetch(rid, updates);\n      pending.shift();\n\n      if (pending.length) fetch(rid);else {\n        adapter.loading(false);\n        bindEvents();\n        adapter.calculateProperties();\n      }\n    }\n\n    function fetch(rid) {\n      if (pending[0]) {\n        // scrolling down\n        if (buffer.length && !viewport.shouldLoadBottom()) {\n          adjustBufferAfterFetch(rid);\n        } else {\n          fetchNext(function (result) {\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            if (result.length < bufferSize) {\n              buffer.eof = true;\n            }\n\n            if (result.length > 0) {\n              viewport.clipTop();\n              buffer.append(result);\n            }\n\n            adjustBufferAfterFetch(rid);\n          });\n        }\n      } else {\n        // scrolling up\n        if (buffer.length && !viewport.shouldLoadTop()) {\n          adjustBufferAfterFetch(rid);\n        } else {\n          fetchPrevious(function (result) {\n            if (isInvalid(rid)) {\n              return;\n            }\n\n            if (result.length < bufferSize) {\n              buffer.bof = true;\n              // log 'bof is reached'\n            }\n\n            if (result.length > 0) {\n              if (buffer.length) {\n                viewport.clipBottom();\n              }\n              buffer.prepend(result);\n            }\n\n            adjustBufferAfterFetch(rid);\n          });\n        }\n      }\n    }\n\n    function resizeAndScrollHandler() {\n      if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n\n        enqueueFetch(ridActual);\n\n        if (pending.length) {\n          unbindEvents();\n        } else {\n          adapter.calculateProperties();\n          !$scope.$$phase && $scope.$digest();\n        }\n      }\n    }\n\n    function wheelHandler(event) {\n      if (!adapter.disabled) {\n        var scrollTop = viewport[0].scrollTop;\n        var yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n        if (scrollTop === 0 && !buffer.bof || scrollTop === yMax && !buffer.eof) {\n          event.preventDefault();\n        }\n      }\n    }\n  }\n}]);\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// ui-scroll.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 34380bdd85f032eea2e2","function getCtrlOnData(attr, element) {\r\n  let onSyntax = attr.match(/^(.+)(\\s+on\\s+)(.+)?/);\r\n  if (onSyntax && onSyntax.length === 4) {\r\n    window.console.log('Angular ui-scroll adapter assignment warning. \"Controller On\" syntax has been deprecated since ui-scroll v1.6.1.');\r\n    let ctrl = onSyntax[3];\r\n    let tail = onSyntax[1];\r\n    let candidate = element;\r\n    while (candidate.length) {\r\n      let candidateScope = candidate.scope(); // doesn't work when debugInfoEnabled flag = true\r\n      let candidateName = (candidate.attr('ng-controller') || '').match(/(\\w(?:\\w|\\d)*)(?:\\s+as\\s+(\\w(?:\\w|\\d)*))?/);\r\n      if (candidateName && candidateName[1] === ctrl) {\r\n        return {\r\n          target: candidateScope,\r\n          source: tail\r\n        };\r\n      }\r\n      candidate = candidate.parent();\r\n    }\r\n    throw new Error('Angular ui-scroll adapter assignment error. Failed to locate target controller \"' + ctrl + '\" to inject \"' + tail + '\"');\r\n  }\r\n}\r\n\r\nclass Adapter {\r\n\r\n  constructor(viewport, buffer, adjustBuffer, reload, $attr, $parse, element, $scope) {\r\n    this.viewport = viewport;\r\n    this.buffer = buffer;\r\n    this.adjustBuffer = adjustBuffer;\r\n    this.reload = reload;\r\n\r\n    this.isLoading = false;\r\n    this.disabled = false;\r\n\r\n    const viewportScope = viewport.getScope();\r\n    this.startScope = viewportScope.$parent ? viewportScope : $scope;\r\n\r\n    this.publicContext = {};\r\n    this.assignAdapter($attr.adapter, $parse, element);\r\n    this.generatePublicContext($attr, $parse);\r\n  }\r\n\r\n  assignAdapter(adapterAttr, $parse, element) {\r\n    if (!adapterAttr || !(adapterAttr = adapterAttr.replace(/^\\s+|\\s+$/gm, ''))) {\r\n      return;\r\n    }\r\n    let ctrlOnData = getCtrlOnData(adapterAttr, element);\r\n    let adapterOnScope;\r\n\r\n    try {\r\n      if (ctrlOnData) { // \"Controller On\", deprecated since v1.6.1\r\n        $parse(ctrlOnData.source).assign(ctrlOnData.target, {});\r\n        adapterOnScope = $parse(ctrlOnData.source)(ctrlOnData.target);\r\n      }\r\n      else {\r\n        $parse(adapterAttr).assign(this.startScope, {});\r\n        adapterOnScope = $parse(adapterAttr)(this.startScope);\r\n      }\r\n    }\r\n    catch (error) {\r\n      error.message = `Angular ui-scroll Adapter assignment exception.\\n` +\r\n        `Can't parse \"${adapterAttr}\" expression.\\n` +\r\n        error.message;\r\n      throw error;\r\n    }\r\n\r\n    angular.extend(adapterOnScope, this.publicContext);\r\n    this.publicContext = adapterOnScope;\r\n  }\r\n\r\n  generatePublicContext($attr, $parse) {\r\n    // these methods will be accessible out of ui-scroll via user defined adapter\r\n    const publicMethods = ['reload', 'applyUpdates', 'append', 'prepend', 'isBOF', 'isEOF', 'isEmpty'];\r\n    for (let i = publicMethods.length - 1; i >= 0; i--) {\r\n      this.publicContext[publicMethods[i]] = this[publicMethods[i]].bind(this);\r\n    }\r\n\r\n    // these read-only props will be accessible out of ui-scroll via user defined adapter\r\n    const publicProps = ['isLoading', 'topVisible', 'topVisibleElement', 'topVisibleScope', 'bottomVisible', 'bottomVisibleElement', 'bottomVisibleScope'];\r\n    for (let i = publicProps.length - 1; i >= 0; i--) {\r\n      let property, attr = $attr[publicProps[i]];\r\n      Object.defineProperty(this, publicProps[i], {\r\n        get: () => property,\r\n        set: (value) => {\r\n          property = value;\r\n          this.publicContext[publicProps[i]] = value;\r\n          if (attr) {\r\n            $parse(attr).assign(this.startScope, value);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // non-read-only public property\r\n    Object.defineProperty(this.publicContext, 'disabled', {\r\n      get: () => this.disabled,\r\n      set: (value) => (!(this.disabled = value)) ? this.adjustBuffer() : null\r\n    });\r\n  }\r\n\r\n  loading(value) {\r\n    this['isLoading'] = value;\r\n  }\r\n\r\n  isBOF() {\r\n    return this.buffer.bof;\r\n  }\r\n\r\n  isEOF() {\r\n    return this.buffer.eof;\r\n  }\r\n\r\n  isEmpty() {\r\n    return !this.buffer.length;\r\n  }\r\n\r\n  applyUpdates(arg1, arg2) {\r\n    if (angular.isFunction(arg1)) {\r\n      // arg1 is the updater function, arg2 is ignored\r\n      this.buffer.slice(0).forEach((wrapper) => {\r\n        // we need to do it on the buffer clone, because buffer content\r\n        // may change as we iterate through\r\n        this.applyUpdate(wrapper, arg1(wrapper.item, wrapper.scope, wrapper.element));\r\n      });\r\n    } else {\r\n      // arg1 is item index, arg2 is the newItems array\r\n      if (arg1 % 1 !== 0) {// checking if it is an integer\r\n        throw new Error('applyUpdates - ' + arg1 + ' is not a valid index');\r\n      }\r\n\r\n      const index = arg1 - this.buffer.first;\r\n      if ((index >= 0 && index < this.buffer.length)) {\r\n        this.applyUpdate(this.buffer[index], arg2);\r\n      }\r\n    }\r\n\r\n    this.adjustBuffer();\r\n  }\r\n\r\n  append(newItems) {\r\n    this.buffer.append(newItems);\r\n    this.adjustBuffer();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  prepend(newItems) {\r\n    this.buffer.prepend(newItems);\r\n    this.adjustBuffer();\r\n    this.viewport.clipTop();\r\n    this.viewport.clipBottom();\r\n  }\r\n\r\n  calculateProperties() {\r\n    let rowTop = null, topHeight = 0;\r\n    let topDone = false, bottomDone = false;\r\n    const length = this.buffer.length;\r\n\r\n    for (let i = 0; i < length; i++) {\r\n      const item = this.buffer[i];\r\n      const itemTop = item.element.offset().top;\r\n\r\n      if (rowTop !== itemTop) { // a new row condition\r\n        const itemHeight = item.element.outerHeight(true);\r\n        const top = this.viewport.topDataPos() + topHeight + itemHeight;\r\n\r\n        if (!topDone && top > this.viewport.topVisiblePos()) {\r\n          topDone = true;\r\n          this['topVisible'] = item.item;\r\n          this['topVisibleElement'] = item.element;\r\n          this['topVisibleScope'] = item.scope;\r\n        }\r\n\r\n        if (!bottomDone && (top >= this.viewport.bottomVisiblePos() || (i === length - 1 && this.isEOF()))) {\r\n          bottomDone = true;\r\n          this['bottomVisible'] = item.item;\r\n          this['bottomVisibleElement'] = item.element;\r\n          this['bottomVisibleScope'] = item.scope;\r\n        }\r\n        topHeight += itemHeight;\r\n      }\r\n\r\n      rowTop = itemTop;\r\n\r\n      if (topDone && bottomDone) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  applyUpdate(wrapper, newItems) {\r\n    if (!angular.isArray(newItems)) {\r\n      return;\r\n    }\r\n\r\n    let keepIt;\r\n    let pos = (this.buffer.indexOf(wrapper)) + 1;\r\n\r\n    newItems.reverse().forEach((newItem) => {\r\n      if (newItem === wrapper.item) {\r\n        keepIt = true;\r\n        pos--;\r\n      } else {\r\n        this.buffer.insert(pos, newItem);\r\n      }\r\n    });\r\n\r\n    if (!keepIt) {\r\n      wrapper.op = 'remove';\r\n    }\r\n  }\r\n\r\n}\r\n\r\nexport default Adapter;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/adapter.js","export default function ScrollBuffer(elementRoutines, bufferSize) {\r\n  const buffer = Object.create(Array.prototype);\r\n\r\n  angular.extend(buffer, {\r\n    size: bufferSize,\r\n\r\n    reset(startIndex) {\r\n      buffer.remove(0, buffer.length);\r\n      buffer.eof = false;\r\n      buffer.bof = false;\r\n      buffer.first = startIndex;\r\n      buffer.next = startIndex;\r\n      buffer.minIndex = startIndex;\r\n      buffer.maxIndex = startIndex;\r\n      buffer.minIndexUser = null;\r\n      buffer.maxIndexUser = null;\r\n    },\r\n\r\n    append(items) {\r\n      items.forEach((item) => {\r\n        ++buffer.next;\r\n        buffer.insert('append', item);\r\n      });\r\n      buffer.maxIndex = buffer.eof ? buffer.next - 1 : Math.max(buffer.next - 1, buffer.maxIndex);\r\n    },\r\n\r\n    prepend(items) {\r\n      items.reverse().forEach((item) => {\r\n        --buffer.first;\r\n        buffer.insert('prepend', item);\r\n      });\r\n      buffer.minIndex = buffer.bof ? buffer.minIndex = buffer.first : Math.min(buffer.first, buffer.minIndex);\r\n    },\r\n\r\n    /**\r\n     * inserts wrapped element in the buffer\r\n     * the first argument is either operation keyword (see below) or a number for operation 'insert'\r\n     * for insert the number is the index for the buffer element the new one have to be inserted after\r\n     * operations: 'append', 'prepend', 'insert', 'remove', 'update', 'none'\r\n     */\r\n    insert(operation, item) {\r\n      const wrapper = {\r\n        item: item\r\n      };\r\n\r\n      if (operation % 1 === 0) {// it is an insert\r\n        wrapper.op = 'insert';\r\n        buffer.splice(operation, 0, wrapper);\r\n      } else {\r\n        wrapper.op = operation;\r\n        switch (operation) {\r\n          case 'append':\r\n            buffer.push(wrapper);\r\n            break;\r\n          case 'prepend':\r\n            buffer.unshift(wrapper);\r\n            break;\r\n        }\r\n      }\r\n    },\r\n\r\n    // removes elements from buffer\r\n    remove(arg1, arg2) {\r\n      if (angular.isNumber(arg1)) {\r\n        // removes items from arg1 (including) through arg2 (excluding)\r\n        for (let i = arg1; i < arg2; i++) {\r\n          elementRoutines.removeElement(buffer[i]);\r\n        }\r\n\r\n        return buffer.splice(arg1, arg2 - arg1);\r\n      }\r\n      // removes single item(wrapper) from the buffer\r\n      buffer.splice(buffer.indexOf(arg1), 1);\r\n\r\n      return elementRoutines.removeElementAnimated(arg1);\r\n    },\r\n\r\n    effectiveHeight(elements) {\r\n      if (!elements.length) {\r\n        return 0;\r\n      }\r\n      let top = Number.MAX_VALUE;\r\n      let bottom = Number.NEGATIVE_INFINITY;\r\n      elements.forEach((wrapper) => {\r\n        if (wrapper.element[0].offsetParent) {\r\n          // element style is not display:none\r\n          top = Math.min(top, wrapper.element.offset().top);\r\n          bottom = Math.max(bottom, wrapper.element.offset().top + wrapper.element.outerHeight(true));\r\n        }\r\n      });\r\n      return Math.max(0, bottom - top);\r\n    }\r\n\r\n  });\r\n\r\n  return buffer;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/buffer.js","export default class ElementRoutines {\r\n\r\n  constructor($injector, $q) {\r\n    this.$animate = ($injector.has && $injector.has('$animate')) ? $injector.get('$animate') : null;\r\n    this.isAngularVersionLessThen1_3 = angular.version.major === 1 && angular.version.minor < 3;\r\n    this.$q = $q;\r\n  }\r\n\r\n  insertElement(newElement, previousElement) {\r\n    previousElement.after(newElement);\r\n    return [];\r\n  }\r\n\r\n  removeElement(wrapper) {\r\n    wrapper.element.remove();\r\n    wrapper.scope.$destroy();\r\n    return [];\r\n  }\r\n\r\n  insertElementAnimated(newElement, previousElement) {\r\n    if (!this.$animate) {\r\n      return this.insertElement(newElement, previousElement);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      // no need for parent - previous element is never null\r\n      this.$animate.enter(newElement, null, previousElement, () => deferred.resolve());\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    // no need for parent - previous element is never null\r\n    return [this.$animate.enter(newElement, null, previousElement)];\r\n  }\r\n\r\n  removeElementAnimated(wrapper) {\r\n    if (!this.$animate) {\r\n      return this.removeElement(wrapper);\r\n    }\r\n\r\n    if (this.isAngularVersionLessThen1_3) {\r\n      const deferred = this.$q.defer();\r\n      this.$animate.leave(wrapper.element, () => {\r\n        wrapper.scope.$destroy();\r\n        return deferred.resolve();\r\n      });\r\n\r\n      return [deferred.promise];\r\n    }\r\n\r\n    return [(this.$animate.leave(wrapper.element)).then(() => wrapper.scope.$destroy())];\r\n  }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/elementRoutines.js","/*!\r\n globals: angular, window\r\n List of used element methods available in JQuery but not in JQuery Lite\r\n element.before(elem)\r\n element.height()\r\n element.outerHeight(true)\r\n element.height(value) = only for Top/Bottom padding elements\r\n element.scrollTop()\r\n element.scrollTop(value)\r\n */\r\n\r\nexport default class JQLiteExtras {\r\n\r\n  registerFor(element) {\r\n    let convertToPx, css, getStyle, isWindow;\r\n    // angular implementation blows up if elem is the window\r\n    css = angular.element.prototype.css;\r\n\r\n    element.prototype.css = function (name, value) {\r\n      let self = this;\r\n      let elem = self[0];\r\n      if (!(!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style)) {\r\n        return css.call(self, name, value);\r\n      }\r\n    };\r\n\r\n    // as defined in angularjs v1.0.5\r\n    isWindow = (obj) => obj && obj.document && obj.location && obj.alert && obj.setInterval;\r\n\r\n    function scrollTo(self, direction, value) {\r\n      let elem = self[0];\r\n      let [method, prop, preserve] = {\r\n        top: [\r\n          'scrollTop',\r\n          'pageYOffset',\r\n          'scrollLeft'\r\n        ],\r\n        left: [\r\n          'scrollLeft',\r\n          'pageXOffset',\r\n          'scrollTop'\r\n        ]\r\n      }[direction];\r\n\r\n      if (isWindow(elem)) {\r\n        if (angular.isDefined(value)) {\r\n          return elem.scrollTo(self[preserve].call(self), value);\r\n        }\r\n        return (prop in elem) ? elem[prop] : elem.document.documentElement[method];\r\n      } else {\r\n        if (angular.isDefined(value)) {\r\n          elem[method] = value;\r\n        }\r\n        return elem[method];\r\n      }\r\n    }\r\n\r\n    if (window.getComputedStyle) {\r\n      getStyle = (elem) => window.getComputedStyle(elem, null);\r\n      convertToPx = (elem, value) => parseFloat(value);\r\n    } else {\r\n      getStyle = (elem) => elem.currentStyle;\r\n      convertToPx = (elem, value) => {\r\n        let left, result, rs, rsLeft, style;\r\n        let core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source;\r\n        let rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i');\r\n\r\n        if (!rnumnonpx.test(value)) {\r\n          return parseFloat(value);\r\n        }\r\n\r\n        // ported from JQuery\r\n        style = elem.style;\r\n        left = style.left;\r\n        rs = elem.runtimeStyle;\r\n        rsLeft = rs && rs.left;\r\n        if (rs) {\r\n          rs.left = style.left;\r\n        }\r\n        // put in the new values to get a computed style out\r\n        style.left = value;\r\n        result = style.pixelLeft;\r\n        style.left = left;\r\n        if (rsLeft) {\r\n          rs.left = rsLeft;\r\n        }\r\n        return result;\r\n      };\r\n    }\r\n\r\n    function getMeasurements(elem, measure) {\r\n      let base, borderA, borderB, computedMarginA, computedMarginB, computedStyle, dirA, dirB, marginA, marginB, paddingA, paddingB;\r\n\r\n      if (isWindow(elem)) {\r\n        base = document.documentElement[{height: 'clientHeight', width: 'clientWidth'}[measure]];\r\n\r\n        return {\r\n          base: base,\r\n          padding: 0,\r\n          border: 0,\r\n          margin: 0\r\n        };\r\n      }\r\n\r\n      // Start with offset property\r\n      [\r\n        base,\r\n        dirA,\r\n        dirB\r\n      ] = {\r\n        width: [\r\n          elem.offsetWidth,\r\n          'Left',\r\n          'Right'\r\n        ],\r\n        height: [\r\n          elem.offsetHeight,\r\n          'Top',\r\n          'Bottom'\r\n        ]\r\n      }[measure];\r\n\r\n      computedStyle = getStyle(elem);\r\n      paddingA = convertToPx(elem, computedStyle['padding' + dirA]) || 0;\r\n      paddingB = convertToPx(elem, computedStyle['padding' + dirB]) || 0;\r\n      borderA = convertToPx(elem, computedStyle['border' + dirA + 'Width']) || 0;\r\n      borderB = convertToPx(elem, computedStyle['border' + dirB + 'Width']) || 0;\r\n      computedMarginA = computedStyle['margin' + dirA];\r\n      computedMarginB = computedStyle['margin' + dirB];\r\n\r\n      // I do not care for width for now, so this hack is irrelevant\r\n      // if ( !supportsPercentMargin )\r\n      // computedMarginA = hackPercentMargin( elem, computedStyle, computedMarginA )\r\n      // computedMarginB = hackPercentMargin( elem, computedStyle, computedMarginB )\r\n      marginA = convertToPx(elem, computedMarginA) || 0;\r\n      marginB = convertToPx(elem, computedMarginB) || 0;\r\n\r\n      return {\r\n        base: base,\r\n        padding: paddingA + paddingB,\r\n        border: borderA + borderB,\r\n        margin: marginA + marginB\r\n      };\r\n    }\r\n\r\n    function getWidthHeight(elem, direction, measure) {\r\n      let computedStyle, result;\r\n\r\n      let measurements = getMeasurements(elem, direction);\r\n\r\n      if (measurements.base > 0) {\r\n        return {\r\n          base: measurements.base - measurements.padding - measurements.border,\r\n          outer: measurements.base,\r\n          outerfull: measurements.base + measurements.margin\r\n        }[measure];\r\n      }\r\n\r\n      // Fall back to computed then uncomputed css if necessary\r\n      computedStyle = getStyle(elem);\r\n      result = computedStyle[direction];\r\n\r\n      if (result < 0 || result === null) {\r\n        result = elem.style[direction] || 0;\r\n      }\r\n\r\n      // Normalize \"\", auto, and prepare for extra\r\n      result = parseFloat(result) || 0;\r\n\r\n      return {\r\n        base: result - measurements.padding - measurements.border,\r\n        outer: result,\r\n        outerfull: result + measurements.padding + measurements.border + measurements.margin\r\n      }[measure];\r\n    }\r\n\r\n    // define missing methods\r\n    return angular.forEach({\r\n      before(newElem) {\r\n        var children, elem, i, j, parent, ref, self;\r\n        self = this;\r\n        elem = self[0];\r\n        parent = self.parent();\r\n        children = parent.contents();\r\n        if (children[0] === elem) {\r\n          return parent.prepend(newElem);\r\n        } else {\r\n          for (i = j = 1, ref = children.length - 1; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {\r\n            if (children[i] === elem) {\r\n              angular.element(children[i - 1]).after(newElem);\r\n              return;\r\n            }\r\n          }\r\n          throw new Error('invalid DOM structure ' + elem.outerHTML);\r\n        }\r\n      },\r\n      height (value){\r\n        var self;\r\n        self = this;\r\n        if (angular.isDefined(value)) {\r\n          if (angular.isNumber(value)) {\r\n            value = value + 'px';\r\n          }\r\n          return css.call(self, 'height', value);\r\n        } else {\r\n          return getWidthHeight(this[0], 'height', 'base');\r\n        }\r\n      },\r\n      outerHeight(option) {\r\n        return getWidthHeight(this[0], 'height', option ? 'outerfull' : 'outer');\r\n      },\r\n      outerWidth(option) {\r\n        return getWidthHeight(this[0], 'width', option ? 'outerfull' : 'outer');\r\n      },\r\n\r\n      /*\r\n       The offset setter method is not implemented\r\n       */\r\n      offset(value) {\r\n        let docElem, win;\r\n        let self = this;\r\n        let box = {\r\n          top: 0,\r\n          left: 0\r\n        };\r\n        let elem = self[0];\r\n        let doc = elem && elem.ownerDocument;\r\n\r\n        if (arguments.length) {\r\n          if (value === undefined) {\r\n            return self;\r\n          }\r\n          // TODO: implement setter\r\n          throw new Error('offset setter method is not implemented');\r\n        }\r\n\r\n        if (!doc) {\r\n          return;\r\n        }\r\n\r\n        docElem = doc.documentElement;\r\n\r\n        // TODO: Make sure it's not a disconnected DOM node\r\n\r\n        if (elem.getBoundingClientRect != null) {\r\n          box = elem.getBoundingClientRect();\r\n        }\r\n\r\n        win = doc.defaultView || doc.parentWindow;\r\n\r\n        return {\r\n          top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),\r\n          left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)\r\n        };\r\n      },\r\n      scrollTop(value) {\r\n        return scrollTo(this, 'top', value);\r\n      },\r\n      scrollLeft(value) {\r\n        return scrollTo(this, 'left', value);\r\n      }\r\n    }, (value, key) => {\r\n      if (!element.prototype[key]) {\r\n        return element.prototype[key] = value;\r\n      }\r\n    });\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/jqLiteExtras.js","import Padding from './padding';\r\n\r\nexport default function Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding) {\r\n  let topPadding = null;\r\n  let bottomPadding = null;\r\n  const viewport = viewportController && viewportController.viewport ? viewportController.viewport : angular.element(window);\r\n  const container = viewportController && viewportController.container ? viewportController.container : undefined;\r\n  const scope = viewportController && viewportController.scope ? viewportController.scope : $rootScope;\r\n\r\n  viewport.css({\r\n    'overflow-anchor': 'none',\r\n    'overflow-y': 'auto',\r\n    'display': 'block'\r\n  });\r\n\r\n  function bufferPadding() {\r\n    return viewport.outerHeight() * padding; // some extra space to initiate preload\r\n  }\r\n\r\n  angular.extend(viewport, {\r\n    getScope() {\r\n      return scope;\r\n    },\r\n\r\n    createPaddingElements(template) {\r\n      topPadding = new Padding(template);\r\n      bottomPadding = new Padding(template);\r\n      element.before(topPadding);\r\n      element.after(bottomPadding);\r\n    },\r\n\r\n    applyContainerStyle() {\r\n      if (container && container !== viewport) {\r\n        viewport.css('height', window.getComputedStyle(container[0]).height);\r\n      }\r\n    },\r\n\r\n    bottomDataPos() {\r\n      let scrollHeight = viewport[0].scrollHeight;\r\n      scrollHeight = scrollHeight != null ? scrollHeight : viewport[0].document.documentElement.scrollHeight;\r\n      return scrollHeight - bottomPadding.height();\r\n    },\r\n\r\n    topDataPos() {\r\n      return topPadding.height();\r\n    },\r\n\r\n    bottomVisiblePos() {\r\n      return viewport.scrollTop() + viewport.outerHeight();\r\n    },\r\n\r\n    topVisiblePos() {\r\n      return viewport.scrollTop();\r\n    },\r\n\r\n    insertElement(e, sibling) {\r\n      return elementRoutines.insertElement(e, sibling || topPadding);\r\n    },\r\n\r\n    insertElementAnimated(e, sibling) {\r\n      return elementRoutines.insertElementAnimated(e, sibling || topPadding);\r\n    },\r\n\r\n    shouldLoadBottom() {\r\n      return !buffer.eof && viewport.bottomDataPos() < viewport.bottomVisiblePos() + bufferPadding();\r\n    },\r\n\r\n    clipBottom() {\r\n      // clip the invisible items off the bottom\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.bottomDataPos() - viewport.bottomVisiblePos() - bufferPadding();\r\n\r\n      for (let i = buffer.length - 1; i >= 0; i--) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        bottomPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        buffer.eof = false;\r\n        buffer.remove(buffer.length - overage, buffer.length);\r\n        buffer.next -= overage;\r\n        viewport.adjustPaddings();\r\n      }\r\n    },\r\n\r\n    shouldLoadTop() {\r\n      return !buffer.bof && (viewport.topDataPos() > viewport.topVisiblePos() - bufferPadding());\r\n    },\r\n\r\n    clipTop() {\r\n      // clip the invisible items off the top\r\n      let overage = 0;\r\n      let overageHeight = 0;\r\n      let itemHeight = 0;\r\n      let emptySpaceHeight = viewport.topVisiblePos() - viewport.topDataPos() - bufferPadding();\r\n\r\n      for (let i = 0; i < buffer.length; i++) {\r\n        itemHeight = buffer[i].element.outerHeight(true);\r\n        if (overageHeight + itemHeight > emptySpaceHeight) {\r\n          break;\r\n        }\r\n        topPadding.cache.add(buffer[i]);\r\n        overageHeight += itemHeight;\r\n        overage++;\r\n      }\r\n\r\n      if (overage > 0) {\r\n        // we need to adjust top padding element before items are removed from top\r\n        // to avoid strange behaviour of scroll bar during remove top items when we are at the very bottom\r\n        topPadding.height(topPadding.height() + overageHeight);\r\n        buffer.bof = false;\r\n        buffer.remove(0, overage);\r\n        buffer.first += overage;\r\n      }\r\n    },\r\n\r\n    adjustPaddings() {\r\n      if (!buffer.length) {\r\n        return;\r\n      }\r\n\r\n      // precise heights calculation, items that were in buffer once\r\n      let topPaddingHeight = topPadding.cache.reduce((summ, item) => summ + (item.index < buffer.first ? item.height : 0), 0);\r\n      let bottomPaddingHeight = bottomPadding.cache.reduce((summ, item) => summ + (item.index >= buffer.next ? item.height : 0), 0);\r\n\r\n      // average item height based on buffer data\r\n      let visibleItemsHeight = buffer.reduce((summ, item) => summ + item.element.outerHeight(true), 0);\r\n      let averageItemHeight = (visibleItemsHeight + topPaddingHeight + bottomPaddingHeight) / (buffer.maxIndex - buffer.minIndex + 1);\r\n\r\n      // average heights calculation, items that have never been reached\r\n      let adjustTopPadding = buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser;\r\n      let adjustBottomPadding = buffer.maxIndexUser !== null && buffer.maxIndex < buffer.maxIndexUser;\r\n      let topPaddingHeightAdd = adjustTopPadding ? (buffer.minIndex - buffer.minIndexUser) * averageItemHeight : 0;\r\n      let bottomPaddingHeightAdd = adjustBottomPadding ? (buffer.maxIndexUser - buffer.maxIndex) * averageItemHeight : 0;\r\n\r\n      // paddings combine adjustment\r\n      topPadding.height(topPaddingHeight + topPaddingHeightAdd);\r\n      bottomPadding.height(bottomPaddingHeight + bottomPaddingHeightAdd);\r\n    },\r\n\r\n    onAfterMinIndexSet(topPaddingHeightOld) {\r\n      // additional scrollTop adjustment in case of datasource.minIndex external set\r\n      if (buffer.minIndexUser !== null && buffer.minIndex > buffer.minIndexUser) {\r\n        let diff = topPadding.height() - topPaddingHeightOld;\r\n        viewport.scrollTop(viewport.scrollTop() + diff);\r\n        diff -= viewport.scrollTop();\r\n        if(diff > 0) {\r\n          bottomPadding.height(bottomPadding.height() + diff);\r\n          viewport.scrollTop(viewport.scrollTop() + diff);\r\n        }\r\n      }\r\n    },\r\n\r\n    onAfterPrepend(updates) {\r\n      if (!updates.prepended.length)\r\n        return;\r\n      const height = buffer.effectiveHeight(updates.prepended);\r\n      const paddingHeight = topPadding.height() - height;\r\n      if (paddingHeight >= 0) {\r\n        topPadding.height(paddingHeight);\r\n      }\r\n      else {\r\n        topPadding.height(0);\r\n        viewport.scrollTop(viewport.scrollTop() - paddingHeight);\r\n      }\r\n    },\r\n\r\n    resetTopPadding() {\r\n      topPadding.height(0);\r\n      topPadding.cache.clear();\r\n    },\r\n\r\n    resetBottomPadding() {\r\n      bottomPadding.height(0);\r\n      bottomPadding.cache.clear();\r\n    },\r\n\r\n    removeItem(item) {\r\n      topPadding.cache.remove(item);\r\n      bottomPadding.cache.remove(item);\r\n      return buffer.remove(item);\r\n    }\r\n  });\r\n\r\n  return viewport;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/viewport.js","function Cache() {\r\n  const cache = Object.create(Array.prototype);\r\n\r\n  angular.extend(cache, {\r\n    add(item) {\r\n      for (let i = cache.length - 1; i >= 0; i--) {\r\n        if (cache[i].index === item.scope.$index) {\r\n          cache[i].height = item.element.outerHeight();\r\n          return;\r\n        }\r\n      }\r\n      cache.push({\r\n        index: item.scope.$index,\r\n        height: item.element.outerHeight()\r\n      });\r\n      cache.sort((a, b) => ((a.index < b.index) ? -1 : ((a.index > b.index) ? 1 : 0)));\r\n    },\r\n\r\n    remove(item) {\r\n      for (let i = cache.length - 1; i >= 0; i--) {\r\n        if (cache[i].index === item.scope.$index) {\r\n          cache.splice(i, 1);\r\n          break;\r\n        }\r\n      }\r\n      for (let i = cache.length - 1; i >= 0; i--) {\r\n        if (cache[i].index > item.scope.$index) {\r\n          cache[i].index--;\r\n        }\r\n      }\r\n    },\r\n\r\n    clear() {\r\n      cache.length = 0;\r\n    }\r\n  });\r\n\r\n  return cache;\r\n}\r\n\r\nexport default function Padding(template) {\r\n  let result;\r\n\r\n  switch (template.tagName.toLowerCase()) {\r\n    case 'dl':\r\n      throw new Error(`ui-scroll directive does not support <${template.tagName}> as a repeating tag: ${template.outerHTML}`);\r\n    case 'tr':\r\n      let table = angular.element('<table><tr><td><div></div></td></tr></table>');\r\n      result = table.find('tr');\r\n      break;\r\n    case 'li':\r\n      result = angular.element('<li></li>');\r\n      break;\r\n    default:\r\n      result = angular.element('<div></div>');\r\n  }\r\n\r\n  result.cache = new Cache();\r\n\r\n  return result;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./src/modules/padding.js","import JQLiteExtras from './modules/jqLiteExtras';\nimport ElementRoutines from './modules/elementRoutines.js';\nimport ScrollBuffer from './modules/buffer.js';\nimport Viewport from './modules/viewport.js';\nimport Adapter from './modules/adapter.js';\n\nangular.module('ui.scroll', [])\n\n  .service('jqLiteExtras', () => new JQLiteExtras())\n  .run(['jqLiteExtras', (jqLiteExtras) =>\n    !window.jQuery ? jqLiteExtras.registerFor(angular.element) : null\n  ])\n\n  .directive('uiScrollViewport', function () {\n    return {\n      restrict: 'A',\n      controller: [\n        '$scope',\n        '$element',\n        function (scope, element) {\n          this.container = element;\n          this.viewport = element;\n          this.scope = scope;\n\n          angular.forEach(element.children(), (child => {\n            if (child.tagName.toLowerCase() === 'tbody') {\n              this.viewport = angular.element(child);\n            }\n          }));\n\n          return this;\n        }\n      ]\n    };\n  })\n\n  .directive('uiScroll', [\n    '$log',\n    '$injector',\n    '$rootScope',\n    '$timeout',\n    '$q',\n    '$parse',\n    function (console, $injector, $rootScope, $timeout, $q, $parse) {\n\n      return {\n        require: ['?^uiScrollViewport'],\n        restrict: 'A',\n        transclude: 'element',\n        priority: 1000,\n        terminal: true,\n        link: link\n      };\n\n      function link($scope, element, $attr, controllers, linker) {\n        const match = $attr.uiScroll.match(/^\\s*(\\w+)\\s+in\\s+([(\\w|\\$)\\.]+)\\s*$/);\n        if (!match) {\n          throw new Error('Expected uiScroll in form of \\'_item_ in _datasource_\\' but got \\'' + $attr.uiScroll + '\\'');\n        }\n\n        function parseNumericAttr(value, defaultValue) {\n          let result = $parse(value)($scope);\n          return isNaN(result) ? defaultValue : result;\n        }\n\n        const BUFFER_MIN = 3;\n        const BUFFER_DEFAULT = 10;\n        const PADDING_MIN = 0.3;\n        const PADDING_DEFAULT = 0.5;\n\n        let datasource = null;\n        const itemName = match[1];\n        const datasourceName = match[2];\n        const viewportController = controllers[0];\n        const bufferSize = Math.max(BUFFER_MIN, parseNumericAttr($attr.bufferSize, BUFFER_DEFAULT));\n        const padding = Math.max(PADDING_MIN, parseNumericAttr($attr.padding, PADDING_DEFAULT));\n        let startIndex = parseNumericAttr($attr.startIndex, 1);\n        let ridActual = 0;// current data revision id\n        let pending = [];\n\n        let elementRoutines = new ElementRoutines($injector, $q);\n        let buffer = new ScrollBuffer(elementRoutines, bufferSize);\n        let viewport = new Viewport(elementRoutines, buffer, element, viewportController, $rootScope, padding);\n        let adapter = new Adapter(viewport, buffer, adjustBuffer, reload, $attr, $parse, element, $scope);\n\n        if (viewportController) {\n          viewportController.adapter = adapter;\n        }\n\n        let isDatasourceValid = () => angular.isObject(datasource) && angular.isFunction(datasource.get);\n        datasource = $parse(datasourceName)($scope); // try to get datasource on scope\n        if (!isDatasourceValid()) {\n          datasource = $injector.get(datasourceName); // try to inject datasource as service\n          if (!isDatasourceValid()) {\n            throw new Error(datasourceName + ' is not a valid datasource');\n          }\n        }\n\n        let onRenderHandlers = [];\n        function onRenderHandlersRunner() {\n          if(onRenderHandlers.length) {\n            angular.forEach(onRenderHandlers, (handler) => handler());\n            onRenderHandlers = [];\n          }\n        }\n        function preDefineIndexProperty(datasource, propName) {\n          let getter;\n          // need to postpone min/maxIndexUser processing if the view is empty\n          if(datasource.hasOwnProperty(propName) && !buffer.length) {\n            getter = datasource[propName];\n            delete datasource[propName];\n            onRenderHandlers.push(() => datasource[propName] = getter);\n          }\n        }\n\n        function defineIndexProperty(datasource, propName, propUserName) {\n          let descriptor = Object.getOwnPropertyDescriptor(datasource, propName);\n          if (descriptor && (descriptor.set || descriptor.get)) {\n            return;\n          }\n          let getter;\n          preDefineIndexProperty(datasource, propName);\n          Object.defineProperty(datasource, propName, {\n            set: (value) => {\n              getter = value;\n              buffer[propUserName] = value;\n              let topPaddingHeightOld = viewport.topDataPos();\n              viewport.adjustPaddings();\n              if (propName === 'minIndex') {\n                viewport.onAfterMinIndexSet(topPaddingHeightOld);\n              }\n            },\n            get: () => getter\n          });\n        }\n\n        defineIndexProperty(datasource, 'minIndex', 'minIndexUser');\n        defineIndexProperty(datasource, 'maxIndex', 'maxIndexUser');\n\n        const fetchNext = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.next, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.next,\n              append: buffer.length ? buffer[buffer.length - 1].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        const fetchPrevious = (datasource.get.length !== 2) ?\n          (success) => datasource.get(buffer.first - bufferSize, bufferSize, success) :\n          (success) => {\n            datasource.get({\n              index: buffer.first - bufferSize,\n              prepend: buffer.length ? buffer[0].item : void 0,\n              count: bufferSize\n            }, success);\n          };\n\n        /**\n         * Build padding elements\n         *\n         * Calling linker is the only way I found to get access to the tag name of the template\n         * to prevent the directive scope from pollution a new scope is created and destroyed\n         * right after the builder creation is completed\n         */\n        linker((clone, scope) => {\n          viewport.createPaddingElements(clone[0]);\n          // we do not include the clone in the DOM. It means that the nested directives will not\n          // be able to reach the parent directives, but in this case it is intentional because we\n          // created the clone to access the template tag name\n          scope.$destroy();\n          clone.remove();\n        });\n\n        $scope.$on('$destroy', () => {\n          unbindEvents();\n          viewport.unbind('mousewheel', wheelHandler);\n        });\n\n        viewport.bind('mousewheel', wheelHandler);\n\n        $timeout(() => {\n          viewport.applyContainerStyle();\n          reload();\n        });\n\n        /* Private function definitions */\n\n        function isInvalid(rid) {\n          return (rid && rid !== ridActual) || $scope.$$destroyed;\n        }\n\n        function bindEvents() {\n          viewport.bind('resize', resizeAndScrollHandler);\n          viewport.bind('scroll', resizeAndScrollHandler);\n        }\n\n        function unbindEvents() {\n          viewport.unbind('resize', resizeAndScrollHandler);\n          viewport.unbind('scroll', resizeAndScrollHandler);\n        }\n\n        function reload() {\n          viewport.resetTopPadding();\n          viewport.resetBottomPadding();\n          if (arguments.length) {\n            startIndex = arguments[0];\n          }\n          buffer.reset(startIndex);\n          adjustBuffer();\n        }\n\n        function isElementVisible(wrapper) {\n          return wrapper.element.height() && wrapper.element[0].offsetParent;\n        }\n\n        function visibilityWatcher(wrapper) {\n          if (isElementVisible(wrapper)) {\n            buffer.forEach((item) => {\n              if (angular.isFunction(item.unregisterVisibilityWatcher)) {\n                item.unregisterVisibilityWatcher();\n                delete item.unregisterVisibilityWatcher;\n              }\n            });\n            if (!pending.length) {\n              $timeout(() => adjustBuffer());\n            }\n          }\n        }\n\n        function insertWrapperContent(wrapper, insertAfter) {\n          createElement(wrapper, insertAfter, viewport.insertElement);\n          if (!isElementVisible(wrapper)) {\n            wrapper.unregisterVisibilityWatcher = wrapper.scope.$watch(() => visibilityWatcher(wrapper));\n          }\n          wrapper.element.addClass('ng-hide'); // hide inserted elements before data binding\n        }\n\n        function createElement(wrapper, insertAfter, insertElement) {\n          let promises = null;\n          let sibling = (insertAfter > 0) ? buffer[insertAfter - 1].element : undefined;\n          linker((clone, scope) => {\n            promises = insertElement(clone, sibling);\n            wrapper.element = clone;\n            wrapper.scope = scope;\n            scope[itemName] = wrapper.item;\n          });\n          // ui-scroll-grid apply\n          if (adapter.transform) {\n            let tdInitializer = wrapper.scope.uiScrollTdInitializer;\n            if (tdInitializer && tdInitializer.linking) {\n              adapter.transform(wrapper.scope, wrapper.element);\n            } else {\n              wrapper.scope.uiScrollTdInitializer = {\n                onLink: () => adapter.transform(wrapper.scope, wrapper.element),\n                scope: wrapper.scope\n              };\n            }\n          }\n          return promises;\n        }\n\n        function updateDOM() {\n          let promises = [];\n          const toBePrepended = [];\n          const toBeRemoved = [];\n          const inserted = [];\n\n          buffer.forEach((wrapper, i) => {\n            switch (wrapper.op) {\n              case 'prepend':\n                toBePrepended.unshift(wrapper);\n                break;\n              case 'append':\n                insertWrapperContent(wrapper, i);\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'insert':\n                promises = promises.concat(createElement(wrapper, i, viewport.insertElementAnimated));\n                wrapper.op = 'none';\n                inserted.push(wrapper);\n                break;\n              case 'remove':\n                toBeRemoved.push(wrapper);\n            }\n          });\n\n          toBeRemoved.forEach((wrapper) => promises = promises.concat(viewport.removeItem(wrapper)));\n\n          if (toBePrepended.length)\n            toBePrepended.forEach((wrapper) => {\n              insertWrapperContent(wrapper);\n              wrapper.op = 'none';\n            });\n\n          buffer.forEach((item, i) => item.scope.$index = buffer.first + i);\n\n          return {\n            prepended: toBePrepended,\n            removed: toBeRemoved,\n            inserted: inserted,\n            animated: promises\n          };\n\n        }\n\n        function updatePaddings(rid, updates) {\n          // schedule another adjustBuffer after animation completion\n          if (updates.animated.length) {\n            $q.all(updates.animated).then(() => {\n              viewport.adjustPaddings();\n              adjustBuffer(rid);\n            });\n          } else {\n            viewport.adjustPaddings();\n          }\n        }\n\n        function enqueueFetch(rid, updates) {\n          if (viewport.shouldLoadBottom()) {\n            if (!updates || buffer.effectiveHeight(updates.inserted) > 0) {\n              // this means that at least one item appended in the last batch has height > 0\n              if (pending.push(true) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          } else if (viewport.shouldLoadTop()) {\n            if ((!updates || buffer.effectiveHeight(updates.prepended) > 0) || pending[0]) {\n              // this means that at least one item appended in the last batch has height > 0\n              // pending[0] = true means that previous fetch was appending. We need to force at least one prepend\n              // BTW there will always be at least 1 element in the pending array because bottom is fetched first\n              if (pending.push(false) === 1) {\n                adapter.loading(true);\n                fetch(rid);\n              }\n            }\n          }\n        }\n\n        function adjustBuffer(rid) {\n          if (!rid) { // dismiss pending requests\n            pending = [];\n            rid = ++ridActual;\n          }\n\n          let updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustment\n          !$scope.$$phase && $scope.$digest();\n\n          updates.inserted.forEach(w => w.element.removeClass('ng-hide'));\n          updates.prepended.forEach(w => w.element.removeClass('ng-hide'));\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          enqueueFetch(rid);\n\n          if (!pending.length) {\n            adapter.calculateProperties();\n          }\n        }\n\n        function adjustBufferAfterFetch(rid) {\n          let updates = updateDOM();\n\n          // We need the item bindings to be processed before we can do adjustment\n          !$scope.$$phase && $scope.$digest();\n\n          updates.inserted.forEach(w => w.element.removeClass('ng-hide'));\n          updates.prepended.forEach(w => w.element.removeClass('ng-hide'));\n\n          viewport.onAfterPrepend(updates);\n\n          if (isInvalid(rid)) {\n            return;\n          }\n\n          updatePaddings(rid, updates);\n          onRenderHandlersRunner();\n          enqueueFetch(rid, updates);\n          pending.shift();\n\n          if (pending.length)\n            fetch(rid);\n          else {\n            adapter.loading(false);\n            bindEvents();\n            adapter.calculateProperties();\n          }\n        }\n\n        function fetch(rid) {\n          if (pending[0]) {// scrolling down\n            if (buffer.length && !viewport.shouldLoadBottom()) {\n              adjustBufferAfterFetch(rid);\n            } else {\n              fetchNext((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.eof = true;\n                }\n\n                if (result.length > 0) {\n                  viewport.clipTop();\n                  buffer.append(result);\n                }\n\n                adjustBufferAfterFetch(rid);\n              });\n            }\n          } else {  // scrolling up\n            if (buffer.length && !viewport.shouldLoadTop()) {\n              adjustBufferAfterFetch(rid);\n            } else {\n              fetchPrevious((result) => {\n                if (isInvalid(rid)) {\n                  return;\n                }\n\n                if (result.length < bufferSize) {\n                  buffer.bof = true;\n                  // log 'bof is reached'\n                }\n\n                if (result.length > 0) {\n                  if (buffer.length) {\n                    viewport.clipBottom();\n                  }\n                  buffer.prepend(result);\n                }\n\n                adjustBufferAfterFetch(rid);\n              });\n            }\n          }\n        }\n\n        function resizeAndScrollHandler() {\n          if (!$rootScope.$$phase && !adapter.isLoading && !adapter.disabled) {\n\n            enqueueFetch(ridActual);\n\n            if (pending.length) {\n              unbindEvents();\n            } else {\n              adapter.calculateProperties();\n              !$scope.$$phase && $scope.$digest();\n            }\n          }\n        }\n\n        function wheelHandler(event) {\n          if (!adapter.disabled) {\n            let scrollTop = viewport[0].scrollTop;\n            let yMax = viewport[0].scrollHeight - viewport[0].clientHeight;\n\n            if ((scrollTop === 0 && !buffer.bof) || (scrollTop === yMax && !buffer.eof)) {\n              event.preventDefault();\n            }\n          }\n        }\n      }\n\n    }\n  ]);\n\n\n// WEBPACK FOOTER //\n// ./src/ui-scroll.js"],"sourceRoot":""}